//*****************************************************************************
// Title: GeoFence Analytic implementation
//
// Copyright (c) 2016-2017 Software AG, Darmstadt, Germany and/or its licensors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//*****************************************************************************

package com.industry.analytics.geolocation;

using com.industry.analytics.Data;
using com.industry.analytics.DataConstants;
using com.industry.analytics.Analytic;
using com.industry.analytics.AnalyticObject;
using com.industry.analytics.AnalyticInterface;
using com.industry.analytics.Constants;
using com.industry.analytics.KillInputChannelListeners;


/* @AnalyticDefinition
{
	"name": "GeoFence",
	"description": "Determines if the input data is inside or outside a GEO location.",
	"group": "GeoLocation",
	"documentation": "com/industry/analytics/geolocation/GeoFence.html",
	"inputChannels": [
		{
			"name": "Coordinates",
			"description": "The channel to send in data",
            "dataProperties": ["xValue", "yValue"]
		}
	],
	"outputChannels": [
		{
			"name": "Geofence Events",
			"description": "The channel to output GeoFence data",
            "dataProperties": ["+sValue"]
        }
	],
	"properties": [
		{
			"name": "enableEntry",
			"description": "Defines whether a Data event will be generated when the incoming Data event enters the defined location",
			"type": "boolean",
            "defaultValue": false,
            "optional": true
		},{
			"name": "enableExit",
			"description": "Defines whether a Data event will be generated when the incoming Data event leaves the defined location",
			"type": "boolean",
            "defaultValue": false,
            "optional": true
		},{
			"name": "enableDwell",
			"description": "Defines whether a Data event will be generated when the incoming Data event dwells in the defined location for the period defined by the 'dwellTime' parameter",
			"type": "boolean",
            "defaultValue": false,
            "optional": true
		},{
			"name": "enableInside",
			"description": "Defines whether a Data event will be generated when the incoming Data event is inside the defined location",
			"type": "boolean",
            "defaultValue": false,
            "optional": true
		},{
			"name": "enableOutside",
			"description": "Defines whether a Data event will be generated when the incoming Data event is outside the defined location",
			"type": "boolean",
            "defaultValue": false,
            "optional": true
		},{
			"name": "dwellTime",
			"description": "Defines the duration in seconds that a source needs to be within a geoFence to be considered as dwelling",
			"type": "decimal",
            "defaultValue": 0,
            "optional": "function(value, analytic) { return !analytic.getProperty('enableDwell').value || 'Required if enableDwell is True' }",
            "validator": "function(value) { return value >= 0 || 'Value must be >= 0.0' }",
			"postfix": "(Seconds)"
		},{
			"name": "realtimeDwell",
			"description": "Defines whether the dwell should be based on the Data timestamps or be real time",
			"type": "boolean",
            "optional": true,
			"defaultValue": "Same as useHypertree"
		},{
			"name": "geoFenceOffset",
			"description": "Defines the offset of the geoFenced square boundary from it's centre in metres",
			"type": "decimal",
            "defaultValue": 0,
            "optional": true,
            "validator": "function(value) { return value !== 0 || 'Value must not be 0.0' }",
			"postfix": "(Metres)"
		},{
			"name": "geoFenceRadius",
			"description": "Defines the radius of the geoFenced circle in metres",
			"type": "decimal",
            "defaultValue": 0,
            "optional": true,
            "validator": "function(value) { return value >= 0 || 'Value must be >= 0.0' }",
			"postfix": "(Metres)"
		},{
			"name": "geoFencePolygon",
			"description": "Defines the vertices of the polygon",
			"type": "string",
            "optional": true,
            "validator": "function(value) { return value.match(/^\\[(\"(\\d+(\\.\\d+)?)( +| *, *)(\\d+(\\.\\d+)?)\")(( +| *, *)\"(\\d+(\\.\\d+)?)( +| *, *)(\\d+(\\.\\d+)?)\"){2,}\\]$/g) || 'Invalid geoFencePolygon: example: [\"0 0\", \"10 10\", \"10 0\"]'; }",
			"postfix": "([\"lat lng\", ...])"
		},{
			"name": "geoFenceLatitude",
			"description": "Defines the latitude for the reference point of the GeoFence. You also need to define the geoFenceLongitude",
			"type": "decimal",
            "defaultValue": 0,
            "optional": true,
		},{
			"name": "geoFenceLongitude",
			"description": "Defines the longitude for the reference point of the GeoFence. You also need to define the geoFenceLatitude",
			"type": "decimal",
            "defaultValue": 0,
            "optional": true,
		},{
			"name": "geoFenceLatitudeParam",
			"description": "Defines the parameters which will contain the latitude coordinate for the reference point of the GeoFence. You also need to define the geoFenceLongitudeParam",
			"type": "string",
            "defaultValue": "0",
            "optional": true
		},{
			"name": "geoFenceLongitudeParam",
			"description": "Defines the parameters which will contain the longitude coordinate for the reference point of the GeoFence. You also need to define the geoFenceLatitudeParam",
			"type": "string",
            "defaultValue": "0",
            "optional": true
		},{
			"name": "useCartesianCoords",
			"description": "Whether to use cartesian coordinates (true) or GPS coordinates (false)",
			"type": "boolean",
            "defaultValue": false,
            "optional": true,
			"advanced":true
		},{
			"name": "useHypertree",
			"description": "Whether to use the hypertree (true) or the Analytics object processData action (false)",
			"type": "boolean",
            "defaultValue": false,
            "optional": true,
			"advanced":true
		},{
            "name": "managementId",
            "description": "Defines the id used for management of the analytic",
            "type": "string",
            "optional": true,
            "advanced": true
        }
	]
}
*/


/** Event for killing the realtime dwell listener when an source exits the geoFence.
 *  Necessary as the exit Data may not be enabled and is sent to the wrong channel
 *  in any case.
 *  @private */
event Exit
{
	string sourceId;
}


/** Event for holding and parsing details of a point's location.
 *  @private */
event Point
{
	decimal x;
	decimal y;
	
	
	/** 
	 *  Static init action creating a Point from a string of two space or comma
	 *  separated decimal values.
	 *
	 *  @param  sPoint  The string to be parsed to create the Point event.
	 *
	 *  @returns The Point event generated from trhe parsed string. If the
	 *           parsing fails x and y are set to NaN and the event considered
	 *           invalid.
	 *
	 *  @private
	 */
	static action init(string sPoint) returns Point
	{
		Point p := new Point;
		p.x := decimal.NAN;
		p.y := decimal.NAN;
		
		sequence<string> sPoints;
		sPoints := " ,".tokenize(sPoint.ltrim().rtrim());
		if sPoints.size() != 2 then
		{
			log "There must be two values in the string to be parsed: '" + sPoint + "'." at ERROR;
		}
		else
		{
			p.x := parseDecimal(sPoints[0]);
			p.y := parseDecimal(sPoints[1]);
		}
		return p;
	}
	
	
	/**
	 *  Parse a decimal from a string with error checking.
	 *
	 *  @param  value  The string to be parsed as a decimal.
	 *
	 *  @returns The decimal value or NaN if parsing fails.
	 *
	 *  @private
	 */
	static action parseDecimal(string value) returns decimal
	{
		if decimal.canParse(value) then
		{
			return decimal.parse(value);
		}
		else
		{
			log "Invalid decimal value: " + value at ERROR;
			return decimal.NAN;
		}
	}
	
	
	/**
	 *  Action for checking whether the given event instance is valid or not.
	 *
	 *  @returns A boolean indicating whether the event instance is valid.
	 *           True if both x and y are legitimate decimal values.
	 *
	 *  @private
	 */
	action isValid() returns boolean
	{
		if x.isNaN() or y.isNaN() then {return false;}
		else {return true;}
	}
}


/**
 *  Event for creating and testing a polygon geofence.
 *  Algorithm from allenryderflex.com/polygon/
 *
 *  @private
 */
event Polygon
{
	sequence<Point> _vertices;
	sequence<decimal> _constants;
	sequence<decimal> _multiples;
	location _boundingBox;
	decimal _offset;
	boolean _crossesDateline;
	boolean _useCartesianCoords;

	
	/**
	 *  Creates a Polygon event based entirely on the vertex points provided.
	 *
	 *  @param sVertices sequence<string> of polygon vertices,
	 *  @param useCartesianCoords Whether the vertices are cartesian or based on lat/long.
	 *
	 *  @returns A Polygon event created from the incoming data.
	 */
	static action initAbsolute(sequence<string> sVertices, boolean useCartesianCoords) returns Polygon
	{
		Polygon polygon := _parseVertices(sVertices);
		polygon._useCartesianCoords := useCartesianCoords; 
		
		if polygon.isValid() then
		{
			polygon._preProcess();
		}
		
		return polygon;
	}
	
	
	/**
	 *  Creates a Polygon event based on the vertex points provided relative to a fixed point.
	 *
	 *  @param latitude Latitide, or cartesian y, value of polygon fixed point. 
     *  @param longitude Longitude, or cartesian x, value of polygon fixed point. 
	 *  @param sVertices sequence<string> of polygon vertices,
	 *  @param useCartesianCoords Whether the vertices are cartesian or based on lat/long.
	 *
	 *  @returns A Polygon event created from the incoming data.
	 */
	static action initRelative(decimal latitude, decimal longitude, sequence<string> sVertices, boolean useCartesianCoords) returns Polygon
	{
		Polygon polygon := _parseVertices(sVertices);
		polygon._useCartesianCoords := useCartesianCoords; 
		
		if polygon.isValid() then
		{
			Point point;
			for point in polygon._vertices
			{
				point.x := point.x + longitude;
				if not useCartesianCoords then
				{
					if point.x > 180.0d then {point.x := point.x - 360.0d;}
					if point.x < -180.0d then {point.x := point.x + 360.0d;}
				}
				point.y := point.y + latitude;
			}

			polygon._preProcess();
		}
		
		return polygon;
	}
	
	
	/**
	 *  Parse a sequence of string vertices in to points, returning the resulting Polygon.
	 *
	 *  @param sVertices sequence<string> of polygon vertices,
	 *
	 *  @returns A Polygon event created from the incoming data.
	 *
	 *  @private
	 */
	static action _parseVertices(sequence<string> sVertices) returns Polygon
	{
		log "Vertex list: " + sVertices.toString() at DEBUG;
		Polygon polygon := new Polygon;
		
		// Can't create a valid polygon from a point or a line.
		if sVertices.size() < 3 then
		{
			log "A GeoFence polygon must have at least three vertices. " + sVertices.size().toString() +
				" supplied: " + sVertices.toString() at ERROR;
			return polygon;
		}
		
		string sVertex;
		for sVertex in sVertices
		{
			Point point := Point.init(sVertex);
			if point.isValid() then
			{
				polygon._vertices.append(point);
			}
			else
			{
				polygon._vertices.clear();
				log "Unable to successfully parse Polygon from: " + sVertices.toString() at ERROR;
				return polygon;
			}
		}
		return polygon;
	}
	
	
	/**
	 *  Do the pre=processing possible up front for checking whether a point is within the polygon.
	 *
	 *  @private
	 */
	action _preProcess()
	{
		boolean result := true;
		
		// Pre-process for geoFence analysing.
		_boundingBox.x1 := float.NAN;
		_boundingBox.x2 := float.NAN;
		_boundingBox.y1 := float.NAN;
		_boundingBox.y2 := float.NAN;
		
		// Check coords are valid if using latitude/longitude.
		if not _useCartesianCoords then
		{
			// Need to run through the vertices initially to see whether we cross the dateline,
			// and whether the coord is valid for a lat/long corrd system.
			// If so we'll add an offset so that we avoid that issue for the actual checks.
			integer i := 0;
			integer j := _vertices.size() - 1;
			while i < _vertices.size()
			{
				Point pI := _vertices[i];
				Point pJ := _vertices[j];

				// Set location bounding box

				// Latitude: watch out for the dateline.
				// For the bounding box we'll shift stuff by +360 degrees.
				// Can't do a shift as we go along as we need to do it for
				// all the preceding points too. Still need to complete
				// validity check though.
				if pI.x < -180.0d or pI.x > 180.0d or pI.y < -90.0d or pI.y > 90.0d then
				{
					log "Invalid lat/long vertex: " + pI.x.toString() + ", " + pI.y.toString() at ERROR;
					result := false;
				}
				// We'll assume that no polygon vertex will be more than half a hemisphere from its neighbour.
				// Thus, if it apparently is, we'll assume the real connection is across the dateline instead.
				if pJ.x.abs() + pI.x.abs() > 180.0d then
				{
					_crossesDateline := true;
				}
				j := i;
				i := i + 1;
			}
			// If there's a problem with the vertices, junk the Polygon so that it becomes invalid
			// and can't be used.
			if not result then
			{
				_vertices.clear();
				return;
			}

			if _crossesDateline then
			{
				Point point;
				for point in _vertices
				{
					// For ease of checking we're going to bring the Polygon into
					// a consistent coordinate set.
					if point.x < 0.0d then {point.x := point.x + 360.0d;}
				}
			}
		}
		
		integer i := 0;
		integer j := _vertices.size() - 1;
		while i < _vertices.size()
		{
			Point pI := _vertices[i];
			Point pJ := _vertices[j];
			if pJ.y = pI.y then
			{
				_constants.append(pI.x);
				_multiples.append(0.0d);
			}
			else
			{
				_constants.append(pI.x - (pI.y * pJ.x) / (pJ.y - pI.y) + (pI.y * pI.x) / (pJ.y - pI.y));
				_multiples.append((pJ.x - pI.x) / (pJ.y - pI.y));
			}		

			// Bounding box.
			if pI.x.toFloat() < _boundingBox.x1 or _boundingBox.x1.isNaN() then
			{
				_boundingBox.x1 := pI.x.toFloat();
			}
			if pI.x.toFloat() > _boundingBox.x2 or _boundingBox.x2.isNaN() then
			{
				_boundingBox.x2 := pI.x.toFloat();
			}
			
			if pI.y.toFloat() > _boundingBox.y1 or _boundingBox.y1.isNaN() then
			{
				_boundingBox.y1 := pI.y.toFloat();
			}
			if pI.y.toFloat() < _boundingBox.y2 or _boundingBox.y2.isNaN() then
			{
				_boundingBox.y2 := pI.y.toFloat();
			}

			j := i;
			i := i + 1;
		}
	}
	
	
	/**
	 *  Checks whether the Polygon is in a valid state for use.
	 *
	 *  @returns A boolean result for validity.
	 */
	action isValid() returns boolean
	{
		if _vertices.size() >= 3 then {return true;}
		else {return false;}
	}
	
	
	/**
	 *  Returns the horizontal quadrilateral bounding box that contains the polygon.
	 *  For use with the basic hypertree listeners and the first check in processData.
	 *
	 *  @returns A location event containing the outer bounds of the polygon aligned with the x-axis.
	 */
	action getLocation() returns location
	{
		return _boundingBox;
	}
	
	
	/**
	 *  Checks whether the provided point is inside the polygon.
	 *
	 *  @param x Longitude or cartesian x coordinate,
	 *  @param y Latitude or cartesian y coordinate.
	 *
	 *  @returns Whether the point is inside the polygon (true) or outside (false).
	 */
	action isPointInPolygon(decimal x, decimal y) returns boolean
	{
		if x < 0.0d and _crossesDateline then {x := x + 360.0d;}
		
		// If the algorithm passes a polygon edge an odd number of times then the point is
		// inside the polygon.
		boolean oddNodes := false;
		integer i := 0;
		integer j := _vertices.size() - 1;
		while i < _vertices.size()
		{
			if (_vertices[i].y < y and _vertices[j].y >= y) or
			   (_vertices[j].y < y and _vertices[i].y >= y) then
			{
				oddNodes := oddNodes xor (y * _multiples[i] + _constants[i] < x);
			}
			j := i;
			i := i + 1;
		}
		return oddNodes;
	}
}


/**
 *  The Geofence Analytic takes a set of input Data sourceIds and uses the
 *  location object as either a cartesian or GPS location. Based on the
 *  Analytic configuration, a Data event will be generated whenever an input
 *  Data event's location activates one of five triggers in the configuration.
 *  The sourceId could be the device identifier, a completely synthetic identifier,
 *  or perhaps an sourceId higher up a hierarchy for a group calculation in
 *  which the original Data sourceId values are irrelevant. The triggers are
 *  defined within the configuration based on whether the Data is inside the
 *  geoFence, outside the geoFence, has entered the geoFence, has exited the
 *  geoFence or has dwelled within the geoFence longer than a defined period of time.
 *  At least one of these five triggers must be enabled.
 *
 *  There are three types of geoFence available, of which only one can be used in
 *  a given analytic instance.<br>
 *  1) Square, aligned with the x-axis (geoFenceOffset).<br>
 *  2) Circle (geoFenceRadius).<br>
 *  3) Polygon (geoFencePolygon).
 * 
 *  A square and a circle always require a geoFence reference point for their centre,
 *  either defined with the geoFenceLatitude, geoFenceLongitude parameter pair, or
 *  with the geoFenceLatitudeParam, geoFenceLongitude parameter pair. Polygons can
 *  also use the parameter pairs, but may also be defined absolutely with just the vertex
 *  points, without being relative to a reference point. In this latter case, do not
 *  define either of the parameter pairs mentioned.
 *
 *  A cartesian coordinate system is taken as flat and completely arbitrary. As
 *  such, no boundary validation is done on the coordinates received. For GPS,
 *  the latitude and longitude are validated, and the dateline handled. A
 *  current limitation is that the analytic will not correctly handle geoFences
 *  which cross over either pole, nor does it it check for violating this limit.
 *  GPS distance calculations use a Haversine calculation. For cartesian coordinates
 *  latitude parameters are read as the y axis and longitude as the x axis.
 *
 *  When defining a polygon geoFence, it is assumed that no polygon vertex
 *  will be more than half a hemisphere from it's nearest neighbour. This
 *  assumption is used when deciding whether the link between vertices crosses
 *  the dateline or not. The polygon links are assumed to be straight lines,
 *  an assumption which works acceptable over localised areas, but will become
 *  inaccurate over large areas. The polygon is defined in the configuration as
 *  a stringified sequence of stringified vertex points. Each point contains
 *  two decimal values, using space and/or comma as separators. Eg:<br>
 *  ["0 0", "10 10", "10 0"]<br>
 *  ["0,0", "10,10", "10,0"]<br>
 *  ["0, 0", "10, 10", "10, 0"]<br>
 *  There must be at least 3 vertices as neither a point nor a line is valid.
 *
 *  GeoFences can be defined in absolute terms or relative to given coordinates
 *  provided within each Data event. This allows a variety of different use
 *  cases to be used.
 *
 *  The analytic has two running modes. The first is the standard Industry Analytics Kit mode
 *  of using the processData action for receiving each Data event. The
 *  second is to use the correlator hypertree directly, via listeners, for Data
 *  events. In the second case, the geoFence can only be defined upfront at init
 *  time, and is fixed for the lifetime of the analytic.
 *
 *  The incoming Data events must have their xValues and yValues set to the coordinates
 *  to be checked. xValue must be the x cartesian value or longitude, yValue the y
 *  cartesian value or latitude.
 *
 *  The analytic can give an output when the source has dwelt within the geofence for
 *  a defined length of time. This can either be based on the Data timestamps, in
 *  which case the output will be generated on the first Data event received after
 *  the dwellTime period. Alternatively, this can be done in real time, using a
 *  correlator wait listener. This should only be used if the data is being received
 *  in real time and the correlator time resolution is acceptable (default = 100ms).
 *  In essence, the first method requires confirmation that the source is still resident
 *  in the geoFence after the expiration of the dwell period, whereas the second method
 *  will assume the source is still resident if it has not been explicitly told otherwise.
 *  Only one dwell output will be generated per stay within the geoFence in both cases.
 *
 *  <dl><dt><b>Input Data events:</b></dt>
 *  <dd>Only one Data stream name must be provided. Its Data events must have the xValue and yValue parameters set to the coordinates of the input.</dd>
 *  </dl>
 *  <dl><dt><b>Output Data events:</b></dt>
 *  <dd>A single Data stream name must be provided. The resulting 
 *      Data events will have the same <font face="courier" size="-1">sourceId</font> as the incoming Data event. The string value ("sValue") will contain the action state
 *      of either "ENTERED", "EXITED", "DWELLED", "INSIDE" or "OUTSIDE". All the
 *      <font face="courier" size="-1">params</font> from the triggering input Data are copied to the output Data events.</dd>
 *  </dl>
 *  <dl><dt><b>Params:</b></dt>
 *  <dd>
 *  <table border="1" style="border-collapse: collapse;width:100%">
 *  <tr><th>Param Name</th><th>Description</th><th>Valid Values</th><th>Data Type</th><th>Required</th><th>Default Value</th></tr>
 *  <tr><td><b>enableEntry</b></td><td>Defines whether a Data event will be generated when the incoming Data event enters the defined location.</td>
 *      <td>Stringified boolean</td><td>Boolean</td><td>False</td><td>false</td></tr>
 *  <tr><td><b>enableExit</b></td><td>Defines whether a Data event will be generated when the incoming Data event leaves the defined location.</td>
 *      <td>Stringified boolean</td><td>Boolean</td><td>False</td><td>false</td></tr>
 *  <tr><td><b>enableDwell</b></td><td>Defines whether a Data event will be generated when the incoming Data event dwells in the defined location for the period defined by the "dwellTime" parameter. </td>
 *      <td>Stringified boolean</td><td>Boolean</td><td>False</td><td>false</td></tr>
 *  <tr><td><b>enableInside</b></td><td>Defines whether a Data event will be generated when the incoming Data event is inside the defined location. </td>
 *      <td>Stringified boolean</td><td>Boolean</td><td>False</td><td>false</td></tr>
 *  <tr><td><b>enableOutside</b></td><td>Defines whether a Data event will be generated when the incoming Data event is outside the defined location. </td>
 *      <td>Stringified boolean</td><td>Boolean</td><td>False</td><td>false</td></tr>
 *  <tr><td><b>dwellTime</b></td><td>Defines the duration in seconds that a source needs to be within a geoFence to be considered as dwelling.</td>
 *      <td>Stringified decimal</td><td>Decimal</td><td>True, if enableDwell is enabled.</td><td>0.0</td></tr>
 *  <tr><td><b>realtimeDwell</b></td><td>Defines whether the dwell should be based on the Data timestamps or be real time.</td>
 *      <td>Stringified boolean</td><td>Boolean</td><td>False</td><td>true, if useHypertree is enabled, otherwise false.</td></tr>
 *  <tr><td><b>geoFenceOffset</b></td><td>Defines the offset of the geoFenced square boundary from it's centre in metres</td>
 *      <td>Stringified decimal</td><td>Decimal</td><td>False</td><td>0.0</td></tr>
 *  <tr><td><b>geoFenceRadius</b></td><td>Defines the radius of the geoFenced circle in metres</td>
 *      <td>Stringified decimal</td><td>Decimal</td><td>False</td><td>0.0</td></tr>
 *  <tr><td><b>geoFencePolygon</b></td><td>Defines the vertices of the polygon. See examples above.</td>
 *      <td>Stringified sequence<string></td><td>String</td><td>False</td><td>[]</td></tr>
 *  <tr><td><b>geoFenceLatitude<br>geoFenceLongitude</b></td><td>Use as a pair. Defines the latitude and longitude coordinates for the reference point of the GeoFence.</td>
 *      <td>Stringified decimal</td><td>Decimal</td><td>False</td><td>0.0</td></tr>
 *  <tr><td><b>geoFenceLatitudeParam<br>geoFenceLongitudeParam</b></td><td>Use as a pair. Defines the parameters which will contain the latitude and longitude coordinates for the reference point of the GeoFence. This option cannot be used with the hypertree.</td>
 *      <td>String</td><td>String</td><td>False</td><td>0.0</td></tr>
 *  <tr><td><b>useCartesianCoords</b></td><td>Whether to use cartesian coordinates (true) or GPS coordinates (false).</td>
 *      <td>Stringified boolean</td><td>Boolean</td><td>False</td><td>false</td></tr>
 *  <tr><td><b>useHypertree</b></td><td>Whether to use the hypertree (true) or the Analytics object processData action (false).</td>
 *      <td>Stringified boolean</td><td>Boolean</td><td>False</td><td>false</td></tr>
 *  </table></dd>
 *  </dl>
 *  <dl><dt><b>Example usage:</b></dt>
 <dd><code>
// Define a GeoFence Analytic which takes Data events on the channel "Input1"  
// and uses the events xValue and yValue parameters as latitude and longitude
// to listen for events that are entering or leaving a 100m radius of Big Ben in London. 
// If there a event was received that entered/exited the defined area, then the
// Analytic will publish the event on the output channel "Output1" with the "sValue"
// parameter modified to indicate either "ENTERED" or "EXITED".  This example is better
// used when a small number of GeoFences are required, and a large number of Data events
// for that location are required.
send com.industry.analytics.Analytic("GeoFence", ["Input"], ["Output1"], {"geoFenceRadius":"100", "geoFenceLatitude":"51.500755", 
                                                                          "geoFenceLongitude":"-0.124627", "enableEntry":"true", 
                                                                          "enableExit":"true"} ) to "";

// Define a GeoFence Analytic which takes Data events on the channel "Input1"  
// and checks the events parameters for a "home_latitude" and "home_longitude"
// values to define a center point at which to calculate whether or not the 
// events xValue and yValue parameters (treated as latitude and longitude)
// are within 20m of that radius. If there a event was received that entered
// the defined area and stayed/dwelled inside that area for 60 seconds, then 
// the Analytic will publish the event on the output channel "Output1" with the 
// "sValue" parameter modified to indicate it "DWELLED".  This example is better
// used when a very large number of GeoFences with a lower number of location 
// Data events are required.
send com.industry.analytics.Analytic("GeoFence", ["Input"], ["Output1"], {"geoFenceRadius":"100", "geoFenceLatitudeParam":"home_latitude", 
                                                                          "geoFenceLongitudeParam":"home_longitude", "enableDwell":"true", 
                                                                          "dwellTime":"60.0"} ) to "";
</code></dd>
 *</dl>
 */
event GeoFence
{
	/** This constant defines the name of the Analytic. */
	constant string NAME := "GeoFence";
	
	/** This constant defines the configuration parameter name
	 *  that defines whether a Data event will be generated when
	 *  the incoming Data event enters the defined location */
	constant string ENABLE_ENTRY         := "enableEntry";
	/** This constant defines the configuration parameter name
	 *  that defines whether a Data event will be generated when
	 *  the incoming Data event exits the defined location */
	constant string ENABLE_EXIT          := "enableExit";
	/** This constant defines the configuration parameter name
	 *  that defines whether a Data event will be generated when
	 *  the incoming Data event has a Geolocation that is inside
	 *  the GeoFenced area. */
	constant string ENABLE_INSIDE        := "enableInside";
	/** This constant defines the configuration parameter name
	 *  that defines whether a Data event will be generated when
	 *  the incoming Data event has a Geolocation that is outside
	 *  the GeoFenced area. */
	constant string ENABLE_OUTSIDE       := "enableOutside";
	
	constant string ENTERED := "ENTERED";
	constant string EXITED := "EXITED";
	constant string DWELLED := "DWELLED";
	constant string INSIDE := "INSIDE";
	constant string OUTSIDE := "OUTSIDE";
	
	/** This constant defines the configuration parameter name
	 *  that defines whether a Data event will be generated when
	 *  the incoming Data event dwells within the defined location
	 *  for at least the duration specified by the "dwellTime" parameter */
	constant string ENABLE_DWELL         := "enableDwell";
	/** This constant defines the configuration parameter name
	 *  that defines the minium duration (in seconds) a Data 
	 *  event will need to stay in the location before a Data 
	 *  event is generated for the dwell action. */
	constant string DWELL_TIME := "dwellTime";
	/** This constant defines the configuration parameter name
	 *  that defines the latitude of the geofenced area */
	constant string GEOFENCE_LATITUDE    := "geoFenceLatitude";
	/** This constant defines the configuration parameter name
	 *  that defines the longitude of the geofenced area */
	constant string GEOFENCE_LONGITUDE   := "geoFenceLongitude";
	/** This constant defines the configuration parameter name
	 *  in the Data event that defines the latitude of the geofenced area */
	constant string GEOFENCE_LATITUDE_PARAM    := "geoFenceLatitudeParam";
	/** This constant defines the configuration parameter name
	 *  in the Data event that defines the longitude of the geofenced area */
	constant string GEOFENCE_LONGITUDE_PARAM  := "geoFenceLongitudeParam";
	/** This constant defines the configuration parameter name
	 *  that defines the offset of the geofenced area in metres, when using a square geofence. */
	constant string GEOFENCE_OFFSET := "geoFenceOffset";
	/** This constant defines the configuration parameter name
	 *  that defines the radius of the geofenced area in metres, when using a circular geofence. */
	constant string GEOFENCE_RADIUS := "geoFenceRadius";
	/** This constant defines the configuration parameter name
	 *  that defines the corners of a polygon, when using a polygon geofence. */
	constant string GEOFENCE_POLYGON := "geoFencePolygon";
	/** This constant defines the configuration parameter name
	 *  that defines whether the coordinates should be treated as 
	 *  GPS latitude/longitude points or as cartesian coordinates */
	constant string USE_CARTESIAN_COORDS := "useCartesianCoords";
	/** This constant defines the configuration parameter name
	 *  that defines whether hypertree listeners should be used
	 *  when geoFenceLatitude and geoFenceLongitude are specified. */
	constant string USE_HYPERTREE := "useHypertree";
	/** This constant defines the configuration parameter name
	 *  that defines whether the dwell uses a realtime EPL wait
	 *  listener or is based soley on Data event timestamps. */ 
	constant string REALTIME_DWELL := "realtimeDwell";
	
	/** Defines the constant value for the number of meters in a degree of latitude. 
	 *  Typically used in geo-location distance calculations. */ 
	constant decimal METERS_PER_DEGREE_LATITUDE := 111111.1111d;
	/** Radius of the Earth in metres. No point being more precise with spherical model. */
	constant decimal EARTH_RADIUS := 6371000.0d;
	
	/** The Analytic Base Object implementation 
	 *  @private */
	AnalyticObject _analyticObject;
	
	// State
	/** Cache containing the sources that are currently inside
	 *  the defined geofenced area.  A timestamp of the entry time 
	 *  is cached for use with the dwell handler. 
	 *  @private 
	 */
	dictionary<string/*sourceId*/, decimal/*timestamp*/> _cacheLocationUpdates;
	
	/** Local cached input Data name
	 *  @private */
	string _inputDataName;
	/** Local cached output Data name
	 *  @private */
	string _outputDataName;
	/** Local cached configuration parameter for whether an
	 *  output Data event should be generated when the GeoFence 
	 *  is entered.
	 *  @private */
	boolean  _entryEnabled; 
	/** Local cached configuration parameter for whether an
	 *  output Data event should be generated when the GeoFence 
	 *  is exited.
	 *  @private */
	boolean  _exitEnabled;
	/** Local cached configuration parameter for whether an
	 *  output Data event should be generated when a Geolocation  
	 *  is received that is outside the GeoFenced area.
	 *  @private */
	boolean  _insideEnabled;
	/** Local cached configuration parameter for whether an
	 *  output Data event should be generated when a Geolocation  
	 *  is received that is inside the GeoFenced area.
	 *  @private */
	boolean  _outsideEnabled;
	/** Local cached configuration parameter for whether an
	 *  output Data event should be generated when the GeoFence 
	 *  is dwelled within for the defined period of time.
	 *  @private */
	boolean  _dwellEnabled;
	/** Local cached configuration parameter for the defined
	 *  period of time (in seconds) before it will be counted as  
	 *  being dwelled.
	 *  @private */
	decimal _dwellTime;

	/** Whether to use the hypertree listener implementation or the enriched Data implementation.
	 *  @private */
	boolean _useHypertree;
	/** Parameter to use for latitude on incoming enriched Data when not using hypertree.
	 *  @private */
	string _geoFenceLatitudeParam;
	/** Parameter to use for longitude on incoming enriched Data when not using hypertree.
	 *  @private */
	string _geoFenceLongitudeParam;
	/** Local cached configuration parameter for the GeoFence latitude,
	 *  when this value is fixed for the analytic instance. NaN otherwise.
	 *  @private */
	decimal _geoFenceLatitude;
	/** Local cached configuration parameter for the GeoFence longitude,
	 *  when this value is fixed for the analytic instance. NaN otherwise.
	 *  @private */
	decimal _geoFenceLongitude;
	/** The primary geoLocation based off the coordinates of the geoFence.
	 *  @private */
	location _geoLocationPrimary;
	/** A secondary geoLocation to cover the case when the geoFence crosses the dateline.
	 *  This location will be offset either + or - 360 degress from the primary location in longitude.
	 *  @private */
	location _geoLocationDateline;
	/** Whether the geoFence crosses the dateline.
	 *  @private */
	boolean _crossesDateline;
	/** GeoFence offset in metres.
	 *  @private */
	decimal _geoFenceOffset;
	/** GeoFence radius in metres.
	 *  @private */
	decimal _geoFenceRadius;
	/** String form of geoFence polygon. Required for longer storage when using Data lat/long.
	 *  @private */
	sequence<string> _geoFencePolygonStringSeq;
	/** GeoFence polygon.
	 *  @private */
	Polygon _geoFencePolygon;
	/** Whether we shoud use cartesian coordinates or not.
	 *  @private */
	boolean _useCartesianCoords;
	/** Whether we should be using a wait listener or Data timestamp for
	 *  determining the length of dwell.
	 *  @private */
	boolean _realtimeDwell;

	/** 
	 *  This action creates a new instance of the Analytic.
	 *  Typically, this is called internally by the associated Analytics 
	 *  service monitor when a com.industry.analytics.Analytic event is 
	 *  sent for this type of Analytic.
	 *
	 *  @param  config        The Analytic configuration that 
	 *                        will be used for this instance
	 *  @param  initComplete  The action callback to call when the new Analytic  
	 *                        has been created, or if an error occured.
     *
	 *  @see com.industry.analytics.Analytic           The Analytic configuration event object.
	 *  @see com.industry.analytics.AnalyticInterface  The action interface that can be used 
	 *                                            to interact with the Analytic.
	 */
	action init( Analytic config,
	             action<boolean, AnalyticInterface> initComplete ) {

		if( not _validateConfiguration( config ) ) then {
			initComplete( false, new AnalyticInterface );
			return;
		}
		
		_analyticObject := new AnalyticObject;
		_analyticObject.init( config,
		                      processData,
		                      reset,
		                      initComplete );
		
		if( _useHypertree ) then {
			// We want to process the Data events ourselves for performance reasons.
			_analyticObject.getInputFromChannel(false);
			// Subscribe to the defined input channel.
			on completed KillInputChannelListeners() {
				monitor.subscribe(_inputDataName);
				// Setup the geoFence handler.
				_setupGeoFenceHandler();
			}
		}
	}
	
	/** 
	 *  This helper action validates configuration that was
	 *  used when trying to create a new instance of the Analytic.
	 *  This is called internally, and should not be called directly by 
	 *  the Users application.
	 *  
	 *  @param   config  The Analytic configuration object that is being validated
	 *  @returns A boolean value indicating whether the configuration was valid or not.
	 * 
	 *  @private
	 */
	action _validateConfiguration( Analytic config ) returns boolean {
		boolean result := config.validateParams( NAME, 1, 1, 
		                                         [ ENABLE_ENTRY,            ENABLE_EXIT,               ENABLE_DWELL,         
		                                           ENABLE_INSIDE,           ENABLE_OUTSIDE,            DWELL_TIME,
		                                           GEOFENCE_LATITUDE_PARAM, GEOFENCE_LONGITUDE_PARAM,  GEOFENCE_RADIUS,
		                                           GEOFENCE_LATITUDE,       GEOFENCE_LONGITUDE,	   	   USE_CARTESIAN_COORDS,
		                                           GEOFENCE_OFFSET,			GEOFENCE_POLYGON,		   USE_HYPERTREE,
		                                           REALTIME_DWELL ], 
		       		                          	 [ Constants.BOOLEAN,       Constants.BOOLEAN,         Constants.BOOLEAN,  
		       		                          	   Constants.BOOLEAN,       Constants.BOOLEAN,         Constants.DECIMAL,
		       		                          	   Constants.STRING,        Constants.STRING,          Constants.DECIMAL,
		       		                          	   Constants.DECIMAL,       Constants.DECIMAL,         Constants.BOOLEAN,
		       		                          	   Constants.DECIMAL,		Constants.SEQUENCE_STRING, Constants.BOOLEAN,
		       		                          	   Constants.BOOLEAN ], 
		       		                          	 [ false,                   false,                     false,               
		       		                          	   false,                   false,                     false,
		       		                          	   false,                   false,                     false,
		       		                          	   false,					false,					   false,
		       		                          	   false,					false,					   false,
		       		                          	   false ] );

		// Only check the specific params if the validation was okay
		if( result ) then {
			// Cache the input/output channel names
			_inputDataName := config.inputDataNames[0];
			_outputDataName := config.outputDataNames[0];

			_useCartesianCoords := config.getOrBoolean(USE_CARTESIAN_COORDS, false); 

			// Only one of geoFenceOffset, geoFenceRadius or geoFencePolygon should be defined.
			_geoFenceOffset := config.getOrDecimal(GEOFENCE_OFFSET, decimal.NAN);
			_geoFenceRadius := config.getOrDecimal(GEOFENCE_RADIUS, decimal.NAN);
			_geoFencePolygonStringSeq := config.getOrSequenceString(GEOFENCE_POLYGON, new sequence<string>);
			if _geoFenceOffset.isNaN() and _geoFenceRadius.isNaN() and _geoFencePolygonStringSeq.size() = 0 then
			{
				log "No GeoFence defined: must define one of geoFenceOffset, geoFenceRadius or geoFencePolygon." at ERROR;
				result := false;
			}
			else if not (not _geoFenceOffset.isNaN() xor not _geoFenceRadius.isNaN() xor _geoFencePolygonStringSeq.size() > 0) then
			{
				log "Must only define one of geoFenceOffset, geoFenceRadius or geoFencePolygon." at ERROR;
				result := false;
			}
			else if _geoFenceOffset = 0.0d then
			{
				log "GeoFence with offset cannot be 0 metres in size." at ERROR;
				result := false;
			}
			else if _geoFenceRadius = 0.0d then
			{
				log "GeoFence with radius cannot be 0 metres in size." at ERROR;
				result := false;
			}
			else if config.hasParam(GEOFENCE_POLYGON) and _geoFencePolygonStringSeq.size() < 3 then
			{
				log "GeoFence polygon must have at least 3 vertices." at ERROR;
				result := false;
			}
			
			_geoFenceLatitude  := decimal.NAN;
			_geoFenceLongitude := decimal.NAN;
			// Only one pair of GEOFENCE_LATITUDE<_PARAM> and GEOFENCE_LATITUDE<_PARAM> must be present.
			if config.hasParam(GEOFENCE_LATITUDE_PARAM) and config.hasParam(GEOFENCE_LONGITUDE_PARAM) and
			   not config.hasParam(GEOFENCE_LATITUDE) and  not config.hasParam(GEOFENCE_LONGITUDE) then
			{
				_useHypertree := false;
				_geoFenceLatitudeParam  := config.getString(GEOFENCE_LATITUDE_PARAM);
				_geoFenceLongitudeParam := config.getString(GEOFENCE_LONGITUDE_PARAM);

				// Check that the lat/long and radius values have been defined
				if _geoFenceLatitudeParam = "" or _geoFenceLongitudeParam = "" then
				{
					log "  The Geofence params are incorrectly defined. Latitude param: '" + _geoFenceLatitudeParam.toString() +
					    "', longitude param: '" + _geoFenceLongitudeParam.toString() + "'." at ERROR;
					result := false;				
				} 
			}
			else if config.hasParam(GEOFENCE_LATITUDE) and config.hasParam(GEOFENCE_LONGITUDE) and
			   		not config.hasParam(GEOFENCE_LATITUDE_PARAM) and not config.hasParam(GEOFENCE_LONGITUDE_PARAM) then
			{
				_useHypertree := config.getOrBoolean(USE_HYPERTREE, true);
				_geoFenceLatitude  := config.getDecimal(GEOFENCE_LATITUDE);
				_geoFenceLongitude := config.getDecimal(GEOFENCE_LONGITUDE);

				// Check that the lat/long and radius values have been defined
				if _geoFenceLatitude < -90.0d or _geoFenceLatitude > 90.0d or
				   _geoFenceLongitude < -180.0d or _geoFenceLongitude > 180.0d then
				{
					log "  The Geofence location is incorrectly defined. Latitude: " + _geoFenceLatitude.toString() +
					    ", longitude: " + _geoFenceLongitude.toString() at ERROR;
					result := false;				
				}
				else if _geoFencePolygonStringSeq.size() = 0 then
				{
					_calculateGeoLocation(_geoFenceLatitude, _geoFenceLongitude);
				}
			}
			else if _geoFencePolygonStringSeq.size() = 0 then
			{
				log "Invalid combination of " + GEOFENCE_LATITUDE + ", " + GEOFENCE_LONGITUDE +
					", " + GEOFENCE_LATITUDE_PARAM + " and " + GEOFENCE_LONGITUDE_PARAM +
					". One, but only one, pair of these parameters is mandatory if no GeoFence polygon is defined." at ERROR;
				result := false;
			}
			
			if _geoFenceLatitudeParam != "" and _geoFenceLatitudeParam = _geoFenceLongitudeParam then
			{
				log GEOFENCE_LATITUDE_PARAM + " and " + GEOFENCE_LONGITUDE_PARAM + " are the same. Is this intentional?" at WARN;
			}
			
			// Realtime Dwell: default true if using the hypertree, else default false.
			_realtimeDwell := config.getOrBoolean(REALTIME_DWELL, _useHypertree);
			
			// Get and cache the configuration values
			_entryEnabled   := config.getOrBoolean(ENABLE_ENTRY,   false); 
			_exitEnabled    := config.getOrBoolean(ENABLE_EXIT,    false);
			_insideEnabled  := config.getOrBoolean(ENABLE_INSIDE,  false); 
			_outsideEnabled := config.getOrBoolean(ENABLE_OUTSIDE, false);
			_dwellEnabled   := config.getOrBoolean(ENABLE_DWELL,   false);
			_dwellTime      := config.getOrDecimal(DWELL_TIME,     0.0d);

			// At least one of entry/exit/dwell must be defined and enabled
			if not (_entryEnabled or _exitEnabled or _insideEnabled or _outsideEnabled or _dwellEnabled) then
			{
				log "Must define at least one of "+ ENABLE_ENTRY +
					", " + ENABLE_EXIT +
					", " + ENABLE_INSIDE +
					", " + ENABLE_OUTSIDE +
					" or "+ ENABLE_DWELL + " as true." at ERROR;
				result := false;
			}
			if _dwellEnabled and _dwellTime <= 0.0d then
			{
				log "Param " + DWELL_TIME + " must be defined and greater than 0.0." at ERROR;
				result := false;
			}
			
			// GeoFence Polygon
			if _geoFencePolygonStringSeq.size() >= 3 then
			{
				if _geoFenceLatitude.isNaN() and _geoFenceLatitudeParam = "" then
				{
					// Absolute polygon
					log "Using absolute fixed polygon GeoFence." at DEBUG;
					_geoFencePolygon := Polygon.initAbsolute(_geoFencePolygonStringSeq, _useCartesianCoords);
					if not _geoFencePolygon.isValid() then {result := false;}
				}
				else if not _geoFenceLatitude.isNaN() then
				{
					// Relative polygon, but set up once, now.
					log "Using relative fixed polygon GeoFence." at DEBUG;
					_geoFencePolygon := Polygon.initRelative(_geoFenceLatitude, _geoFenceLongitude, _geoFencePolygonStringSeq, _useCartesianCoords);
					if not _geoFencePolygon.isValid() then {result := false;}
				}
				else
				{
					log "Using relative Data centred polygon." at DEBUG;
				}
				_calculateGeoLocation(_geoFenceLatitude, _geoFenceLongitude);
				/* else we set up the polygon with each Data object using the supplied params. */
			}
			
		}
		
		// This analytic has several variations.
		// Log what is going on so that we can be sure.
		if( result ) then {
			if _entryEnabled then {log "Entry enabled." at DEBUG;}
			if _exitEnabled then {log "Exit enabled." at DEBUG;}
			if _insideEnabled then {log "Inside enabled." at DEBUG;}
			if _outsideEnabled then {log "Outside enabled." at DEBUG;}
			if _dwellEnabled then {log "Dwell enabled." at DEBUG;}
			
			if _useHypertree then {log "Using hypertree." at DEBUG;}
			else {log "Using processData." at DEBUG;}
			if _useCartesianCoords then {log "Using cartesian coordinates." at DEBUG;}
			else {log "Using latitude.longitude coordinates." at DEBUG;}
			if _dwellEnabled then
			{
				if _realtimeDwell then {log "Using realtime dwell." at DEBUG;}
				else {log "Using dwell based on Data timestamps." at DEBUG;}
			}
			
			if not _geoFenceOffset.isNaN() then {log "Using offset GeoFence: " + _geoFenceOffset.toString() at DEBUG;}
			else if not _geoFenceRadius.isNaN() then {log "Using radius GeoFence: " + _geoFenceRadius.toString() at DEBUG;}
		}

		return result;
	}
	
	
	action _calculateGeoLocation(decimal geoFenceLatitude, decimal geoFenceLongitude)
	{
		_crossesDateline := false;
		decimal latitudeOffset;
		decimal longitudeOffset;
		decimal offset := decimal.NAN;
		
		if not _geoFenceOffset.isNaN() then {offset := _geoFenceOffset;}
		else if not _geoFenceRadius.isNaN() then {offset := _geoFenceRadius;}

		if not offset.isNaN() then
		{
			// Check if we want to use cartesian coords instead of GPS lat/longs
			if _useCartesianCoords then
			{
				latitudeOffset  := offset;
				longitudeOffset := offset;
			}
			else
			{
				// Calculate the offset in degrees from the original coordinates based on the radius in meters
				latitudeOffset  := offset / METERS_PER_DEGREE_LATITUDE; 
				longitudeOffset := offset / (METERS_PER_DEGREE_LATITUDE * _toRadians(latitudeOffset).cos()); 
			}
			
			// Calculate the box around the centre point
			_geoLocationPrimary.x1 := (geoFenceLongitude - longitudeOffset).toFloat();
			_geoLocationPrimary.x2 := (geoFenceLongitude + longitudeOffset).toFloat();
			_geoLocationPrimary.y1 := (geoFenceLatitude + latitudeOffset).toFloat();
			_geoLocationPrimary.y2 := (geoFenceLatitude - latitudeOffset).toFloat();
		}
		else /* Polygon */
		{
			if _geoFencePolygon.isValid() then
			{
				_geoLocationPrimary := _geoFencePolygon.getLocation();
			}
		}
		log "GeoFence location bounds: " + _geoLocationPrimary.toString() at DEBUG;

		if not _useCartesianCoords then
		{
			if _geoLocationPrimary.x1 < -180.0 then
			{
				_crossesDateline := true;
				_geoLocationDateline.x1 := _geoLocationPrimary.x1 + 360.0;
				_geoLocationDateline.x2 := _geoLocationPrimary.x2 + 360.0;
				_geoLocationDateline.y1 := _geoLocationPrimary.y1;
				_geoLocationDateline.y2 := _geoLocationPrimary.y2;
			}
			else if _geoLocationPrimary.x2 > 180.0 then
			{
				_crossesDateline := true;
				_geoLocationDateline.x1 := _geoLocationPrimary.x1 - 360.0;
				_geoLocationDateline.x2 := _geoLocationPrimary.x2 - 360.0;
				_geoLocationDateline.y1 := _geoLocationPrimary.y1;
				_geoLocationDateline.y2 := _geoLocationPrimary.y2;
			}
		}
	}


	/** 
	 *  This helper action calculates the Radians for a given decimal.
	 *  This is used in the Haversine calculations.
	 *  @private
	 */
	action _toRadians(decimal d) returns decimal
	{
		return (d * decimal.PI) / 180.0d;
	}

	
	
	/**
	 *  Parse a decimal from a string with error checking.
	 *
	 *  @param  value  The string to be parsed as a decimal.
	 *
	 *  @returns The decimal value or NaN if parsing fails.
	 *
	 *  @private
	 */
	static action _parseDecimal(string value) returns decimal
	{
		if decimal.canParse(value) then
		{
			return decimal.parse(value);
		}
		else
		{
			log "Invalid decimal value: " + value at ERROR;
			return decimal.NAN;
		}
	}


	/**
	 *  This action implements the Analytic function itself. 
	 *  This action should not be called directly by the Users application.
	 *
	 *  This is the internal action that sets up the set of listeners for
	 *  the different conditions that the GeoFence Analytic supports.
	 *
	 *  @private
	 */
	action processData(Data dataIn)
	{
		log "Processing " + dataIn.toString() at DEBUG;
		
		if _useHypertree then
		{
			log "GeoFence Analytic in hypertree mode. This call to processData should not have happened. Skipping." at WARN;
			return;
		}
		
		Data dataOut := dataIn.clone();
		dataOut.streamName := _outputDataName;
		dataOut.type := DataConstants.COMPUTED;
		
		// Make sure the Data event has the Latitude and Longitude parameters defined
		// and their values are valid
		decimal geoFenceLatitude := _geoFenceLatitude;
		decimal geoFenceLongitude := _geoFenceLongitude;
		// If we're not using an absolute geoFence, get the geoFence from the specified Data params.
		if geoFenceLatitude.isNaN() and not _geoFencePolygon.isValid() then
		{
			geoFenceLatitude := _parseDecimal(dataIn.params.getOrDefault(_geoFenceLatitudeParam));
			geoFenceLongitude := _parseDecimal(dataIn.params.getOrDefault(_geoFenceLongitudeParam));
			if geoFenceLatitude.isNaN() or geoFenceLongitude.isNaN() or
			   (not _useCartesianCoords and (geoFenceLatitude < -90.0d or geoFenceLatitude > 90.0d or
			                                 geoFenceLongitude < -180.0d or geoFenceLongitude > 180.0d)) then
			{
				log "Invalid geoFence coordinates, useCartesianCoords: " + _useCartesianCoords.toString() +
					", geoFenceLatitude: " + geoFenceLatitude.toString() +
					", geoFenceLongitude: " + geoFenceLongitude.toString() at ERROR;
				return;
			}

			if _geoFencePolygonStringSeq.size() >= 3 and not _geoFenceLatitudeParam = "" then
			{
				_geoFencePolygon := Polygon.initRelative(geoFenceLatitude, geoFenceLongitude, _geoFencePolygonStringSeq, _useCartesianCoords);
			}
			_calculateGeoLocation(geoFenceLatitude, geoFenceLongitude);
		}
		
		// Check if this Data is inside the square Geofence
		if (dataIn.xValue >= _geoLocationPrimary.x1 and dataIn.xValue <= _geoLocationPrimary.x2 and
		    dataIn.yValue >= _geoLocationPrimary.y2 and dataIn.yValue <= _geoLocationPrimary.y1) or
		   (_crossesDateline and (dataIn.xValue >= _geoLocationDateline.x1 and dataIn.xValue <= _geoLocationDateline.x2 and
		              		      dataIn.yValue >= _geoLocationDateline.y2 and dataIn.yValue <= _geoLocationDateline.y1)) then
		{
			_processSignificantData(dataIn, geoFenceLatitude, geoFenceLongitude);
		}
		else
		{
			// The Data is outside the geoFenced area
			_processOutsideData(dataIn);
		}
	}
	
	
	/** 
	 *  Deals with Data events found to be inside of the geoFence location boundary.
	 *  Determines, based on the type of geoFence in use, whether the Data is
	 *  really inside or outside the geoFence.
	 *
	 *  @param dataIn the Data being processed.
	 *  @param geoFenceLatitude The latitude of the geoFence.
	 *  @param geoFenceLongitude The longitude of the geoFence.
	 *
	 *  @private
	 */
	action _processSignificantData(Data dataIn, decimal geoFenceLatitude, decimal geoFenceLongitude)
	{
		// If the offset is being used then the location boundary is the geoFence.
		if not _geoFenceOffset.isNaN() then
		{
			_processInsideData(dataIn);
		}
		// If the radius is being used then ...
		else if not _geoFenceRadius.isNaN() then
		{
			// Determine how far the Data is from the centre of the geoFence circle.
			decimal offset;
			if _useCartesianCoords then
			{
				// Determine the offset as a circle on a flat geometry.
				offset := ((dataIn.yValue.toDecimal() - geoFenceLatitude).pow(2.0d) +
				   		   (dataIn.xValue.toDecimal() - geoFenceLongitude).pow(2.0d)).sqrt();
			}
			else
			{
				// Determine the offset based on a Haversine calculation.
				decimal geoFenceLatitudeRadians := _toRadians(geoFenceLatitude);
				decimal geoFenceLongitudeRadians := _toRadians(geoFenceLongitude);
				decimal latitude := _toRadians(dataIn.yValue.toDecimal());
				decimal longitude := _toRadians(dataIn.xValue.toDecimal());
				decimal haversine := ((latitude - geoFenceLatitudeRadians) / 2.0d).sin().pow(2.0d) +
									 (geoFenceLatitudeRadians.cos() * latitude.cos() * ((longitude - geoFenceLongitudeRadians) / 2.0d).sin().pow(2.0d));
				offset := 2.0d * EARTH_RADIUS *
						  haversine.sqrt().atan2((1.0d - haversine).sqrt());
			}			 
			
			// Are we in the circle?
			log "Offset: " + offset.toString() at DEBUG;
			if offset <= _geoFenceRadius then
			{
				_processInsideData(dataIn);
			}
			else
			{
				_processOutsideData(dataIn);
			}
		}
		// If the geoFence is a polygon ...
		else if _geoFencePolygon.isValid() then
		{
			if _geoFencePolygon.isPointInPolygon(dataIn.xValue.toDecimal(), dataIn.yValue.toDecimal()) then
			{
				_processInsideData(dataIn);
			}
			else
			{
				_processOutsideData(dataIn);
			}
		}
		else
		{
			log "No active geoFence: this shouldn't happen." at ERROR;
			return;
		}
	}
	
	
	/** 
	 *  Deals with Data events found to be inside of the geoFenced area.
	 *
	 *  @param dataIn the Data being processed.
	 *
	 *  @private
	 */
	action _processInsideData(Data dataIn)
	{
		Data dataOut := dataIn.clone();
		dataOut.streamName := _outputDataName;
		dataOut.type := DataConstants.COMPUTED;
		
		// If the source was last known to be outside of the geofence then ...
		if not _cacheLocationUpdates.hasKey(dataIn.sourceId) then
		{
			// Store when the source entered the geoFence.
			_cacheLocationUpdates.add(dataIn.sourceId, dataIn.timestamp);

			// Send an 'ENTERED' Data.
			if _entryEnabled then
			{
				dataOut.sValue := ENTERED;
				_analyticObject.sendData(dataOut);
			}
			
			// If we're using realtime dwell.
			if _dwellEnabled and _realtimeDwell
			{
				on wait(_dwellTime.toFloat()) and not Exit(sourceId=dataIn.sourceId)
				{
					// Send a 'DWELLED' Data.
					Data dwellOut := dataIn.clone();
					dwellOut.streamName := _outputDataName;
					dwellOut.type       := DataConstants.COMPUTED;
					dwellOut.timestamp  := dataIn.timestamp + _dwellTime;
					dwellOut.sValue     := DWELLED;
					_analyticObject.sendData(dwellOut);
				}
			}
		}
		// If we're using dwell based on the Data timestamps.
		else if _dwellEnabled and not _realtimeDwell and
				dataIn.timestamp - _cacheLocationUpdates[dataIn.sourceId] >= _dwellTime then
		{
			// Send a 'DWELLED' Data.
			dataOut.sValue := DWELLED;
			_analyticObject.sendData(dataOut);
			// Prevent further dwell messages to match realtime behaviour.
			_cacheLocationUpdates[dataIn.sourceId] := decimal.MAX;
		}

		// Send an 'INSIDE' Data.
		if _insideEnabled then
		{
			dataOut.sValue := INSIDE;
			_analyticObject.sendData(dataOut);
		}
	}
	
	
	/** 
	 *  Deals with Data events found to be outside of the geoFenced area.
	 *
	 *  @param dataIn the Data being processed.
	 *
	 *  @private
	 */
	action _processOutsideData(Data dataIn)
	{
		// If the source was last known to be inside the geoFence then ...
		if _cacheLocationUpdates.hasKey(dataIn.sourceId) then
		{
			// Calculate the total dwellTime
			decimal dwellTime := dataIn.timestamp - _cacheLocationUpdates[dataIn.sourceId];
			// Clear the source from the geoFence 'INSIDE' cache.
			_cacheLocationUpdates.remove(dataIn.sourceId);
			// If we're using realtime swell,m the listener needs to be destroyed.
			if _dwellEnabled and _realtimeDwell then {route Exit(dataIn.sourceId);}

			// Send an 'EXITED' Data.
			if _exitEnabled then
			{
				Data dataOut := dataIn.clone();
				dataOut.streamName := _outputDataName;
				dataOut.type       := DataConstants.COMPUTED;
				dataOut.sValue     := EXITED;
				dataOut.params[DWELL_TIME] := dwellTime.toString();
				_analyticObject.sendData(dataOut);
			}
		}

		// Send an 'OUTSIDE' Data.
		if _outsideEnabled then
		{
			Data dataOut := dataIn.clone();
			dataOut.streamName := _outputDataName;
			dataOut.type       := DataConstants.COMPUTED;
			dataOut.sValue     := OUTSIDE;
			_analyticObject.sendData(dataOut);
		}
	}


	/**
	 *  This action implements the Analytic function itself. 
	 *  This action should not be called directly by the Users application.
	 *
	 *  This is the internal action that sets up the set of listeners for
	 *  the different conditions that the GeoFence Analytic supports.
	 *
	 *  @private
	 */
	action _setupGeoFenceHandler()
	{
		// Listen for Data events inside the geoFence.
		Data insideData;
		if _crossesDateline then
		{
			// Is the Data inside the primary geoFence or the dateline adjusted location?
			on (all Data(streamName = _inputDataName,
			                xValue in [_geoLocationPrimary.x1 : _geoLocationPrimary.x2],
			                yValue in [_geoLocationPrimary.y2 : _geoLocationPrimary.y1]) :insideData or
				all Data(streamName = _inputDataName,
			                xValue in [_geoLocationDateline.x1 : _geoLocationDateline.x2],
			                yValue in [_geoLocationDateline.y2 : _geoLocationDateline.y1]) :insideData) and
			   not KillInputChannelListeners(id=_analyticObject._id)
			{
				_processSignificantData(insideData, _geoFenceLatitude, _geoFenceLongitude);
			}
		}
		else
		{
			// Is the Data inside the primary geoFence?
			on all Data(streamName = _inputDataName,
			               xValue in [_geoLocationPrimary.x1 : _geoLocationPrimary.x2],
			               yValue in [_geoLocationPrimary.y2 : _geoLocationPrimary.y1]) :insideData and
			   not KillInputChannelListeners(id=_analyticObject._id)
			{
				_processSignificantData(insideData, _geoFenceLatitude, _geoFenceLongitude);
			}
		}
		
		// Check if it's outside the square area
		Data outsideData;
		if _crossesDateline then
		{
			if _geoLocationPrimary.x1 > _geoLocationDateline.x2 then
			{
				on all (Data(streamName=_inputDataName, xValue in [_geoLocationDateline.x2 :_geoLocationPrimary.x1]) :outsideData or
				        Data(streamName=_inputDataName, yValue > _geoLocationPrimary.y1) :outsideData or
				   	    Data(streamName=_inputDataName, yValue < _geoLocationPrimary.y2) :outsideData) and
				not KillInputChannelListeners(id=_analyticObject._id)
				{
					// Discard 'in' boundary clash
					if (outsideData.xValue = _geoLocationDateline.x2 or outsideData.xValue = _geoLocationPrimary.x1) and
					   outsideData.yValue <= _geoLocationPrimary.y1 and
					   outsideData.yValue >= _geoLocationPrimary.y2 then
					{
						return;
					}
					_processOutsideData(outsideData);
				}
			}
			else
			{
				on all (Data(streamName=_inputDataName, xValue in [_geoLocationPrimary.x2 : _geoLocationDateline.x1]) :outsideData or
				        Data(streamName=_inputDataName, yValue > _geoLocationPrimary.y1) :outsideData or
				   	    Data(streamName=_inputDataName, yValue < _geoLocationPrimary.y2) :outsideData) and
				not KillInputChannelListeners(id=_analyticObject._id)
				{
					if (outsideData.xValue = _geoLocationPrimary.x2 or outsideData.xValue = _geoLocationDateline.x1) and
					   outsideData.yValue <= _geoLocationPrimary.y1 and
					   outsideData.yValue >= _geoLocationPrimary.y2 then
					{
						return;
					}
					_processOutsideData(outsideData);
				}
			}
		}
		else
		{
			on all (Data(streamName=_inputDataName, xValue < _geoLocationPrimary.x1) :outsideData or
			        Data(streamName=_inputDataName, xValue > _geoLocationPrimary.x2) :outsideData or
			        Data(streamName=_inputDataName, yValue < _geoLocationPrimary.y2) :outsideData or
			        Data(streamName=_inputDataName, yValue > _geoLocationPrimary.y1) :outsideData) and
			   not KillInputChannelListeners(id=_analyticObject._id)
			{
				_processOutsideData(outsideData);
			}
		}
	}
	

	/**
	 *  Optional action to reset the state of the analytic instance
	 *  back to its initialisation state.
	 *  This is called internally by the Analytic Object, and  
	 *  should not be called directly by the Users application.
	 *  If the application has created this Analytic using the 
	 *  #init() action directly, then the <font face="courier" size="-1">reset</font>
	 *  action on the <font face="courier" size="-1">com.industry.analytics.AnalyticInterface</font> 
	 *  that was returned should be used instead.
	 *
	 *  @private
	 */
	action reset() {
		_cacheLocationUpdates.clear();
	}
}


/** 
 *  This internal Monitor is used to automatically intern 
 *  any string constants that are defined that are associated
 *  with the Geofence Analytic in order to improve  
 *  performance when handling strings.
 *
 *  Note: The listener that is created is required in order
 *        to keep the monitor alive between a Persistant  
 *        Correlators recovery.  Otherwise, this would be a 
 *        transient monitor, and it would not be recovered.  
 *        Which would then mean that the strings would not
 *        interned in the recovered Correlator.
 *
 *  @private
 */
monitor InternGeofence
{
	event StayAlive {}
	
	action onload()
	{
		string discard := GeoFence.NAME.intern();
		discard := GeoFence.ENABLE_ENTRY.intern();
		discard := GeoFence.ENABLE_EXIT.intern();
		discard := GeoFence.ENABLE_DWELL.intern();
		discard := GeoFence.ENABLE_INSIDE.intern();
		discard := GeoFence.ENABLE_OUTSIDE.intern();
		discard := GeoFence.ENTERED.intern();
		discard := GeoFence.EXITED.intern();
		discard := GeoFence.DWELLED.intern();
		discard := GeoFence.INSIDE.intern();
		discard := GeoFence.OUTSIDE.intern();
		discard := GeoFence.DWELL_TIME.intern();
		discard := GeoFence.GEOFENCE_LATITUDE_PARAM.intern();
		discard := GeoFence.GEOFENCE_LONGITUDE_PARAM.intern();
		discard := GeoFence.GEOFENCE_OFFSET.intern();
		discard := GeoFence.GEOFENCE_RADIUS.intern();
		discard := GeoFence.GEOFENCE_POLYGON.intern();
		discard := GeoFence.USE_CARTESIAN_COORDS.intern();
		discard := GeoFence.USE_HYPERTREE.intern();
		discard := GeoFence.REALTIME_DWELL.intern();

		on all StayAlive() {}
	}
}
